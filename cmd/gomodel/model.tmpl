{{range $model, $fields := .}}
{{$normalModel := $model.Name}}
{{$unexport := $model.UnexportedName}}
{{$upperModel := $model.UpperName}}
{{$self := $model.Self}}
{{$recv := (printf "(%s *%s)" $self $normalModel)}}
const (
    {{range $index, $field := $fields}}{{with $field}}{{.ConstName}}{{end}} {{if eq $index  0}} uint = 1 << iota {{end}}
    {{end}}{{$unexport}}FieldEnd = iota
    {{$unexport}}FieldsAll = 1 << {{$unexport}}FieldEnd-1
    {{range $index, $field := $fields}}{{with $field}}{{$unexport}}FieldsExcp{{.Name}} = {{$unexport}}FieldsAll &(^{{.ConstName}}){{end}}
    {{end}}
)
var (
    // DB is the global DB instance
    {{$unexport}}Info = DB.TypeInfo(&{{$normalModel}}{})
)

func {{$recv}} Table() string {
    return "{{$model.TableName}}"
}

func {{$recv}} Vals(fields uint, vals []interface{}) {
    if fields != 0 {
    if fields == {{$unexport}}FieldsAll {
        {{range $index, $field:=$fields}}vals[{{$index}}]={{$self}}.{{$field.Name}}
        {{end}}
    } else {
       index := 0
    {{range $fields}} if fields&{{.ConstName}} != 0 {
        vals[index] = {{$self}}.{{.Name}}
        index++
        }
    {{end}}  }
    }
}

func {{$recv}} Ptrs(fields uint, ptrs []interface{}) {
    if fields != 0 {
        if fields == {{$unexport}}FieldsAll {
        {{range $index, $field:=$fields}}ptrs[{{$index}}]=&({{$self}}.{{$field.Name}})
        {{end}}
         } else {
        index := 0
        {{range $fields}} if fields&{{.ConstName}} != 0 {
            ptrs[index] = &({{$self}}.{{.Name}})
            index++
        }
    {{end}}}
    }
}

func {{$recv}} New() gomodel.Model {
    return new({{$normalModel}})
}

type (
    {{$unexport}}s struct {
        Items []{{$normalModel}}
        Fields uint
    }
)

func (a *{{$unexport}}s) Make(count int) {
    a.Items = make([]{{$normalModel}}, count)
}

func (a *{{$unexport}}s) Ptrs(index int, ptrs []interface{}) {
    a.Items[index].Ptrs(a.Fields, ptrs)
}
{{end}}
